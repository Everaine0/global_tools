# global_tools/dependency_manager.py
import os
import sys
import toml
import re # Ensure re is imported
from . import utils
from . import config as tool_config # Import the config module

def convert_pyproject_to_req(project_root):
    """Converts pyproject.toml [tool.poetry.dependencies] or [project.dependencies] to requirements.txt."""
    pyproject_path = os.path.join(project_root, 'pyproject.toml')
    req_path = os.path.join(project_root, 'requirements.txt')

    if not os.path.exists(pyproject_path):
        print(f"错误: 未找到 '{os.path.basename(pyproject_path)}' 文件。", file=sys.stderr)
        return

    print(f"正在尝试从 '{os.path.basename(pyproject_path)}' 生成 '{os.path.basename(req_path)}'...")

    try:
        data = toml.load(pyproject_path)
        dependencies = {}
        source_section = "未知"

        # Try Poetry format first
        if 'tool' in data and 'poetry' in data['tool'] and 'dependencies' in data['tool']['poetry']:
            dependencies = data['tool']['poetry']['dependencies']
            source_section = "[tool.poetry.dependencies]"
        # Try PEP 621 format second
        elif 'project' in data and 'dependencies' in data['project']:
             # PEP 621 dependencies are often a list, need conversion
             dep_list = data['project']['dependencies']
             if isinstance(dep_list, list):
                  # Basic conversion from list to dict for compatibility with existing logic
                  # This assumes simple "package" or "package>=version" strings
                  for item in dep_list:
                      match = re.match(r'^([a-zA-Z0-9._-]+)\s*([~<>=!]=?.*)?$', item)
                      if match:
                          name = match.group(1)
                          version_spec = match.group(2).strip() if match.group(2) else "*"
                          dependencies[name] = version_spec
                      else:
                          print(f"警告: 无法解析 PEP621 依赖项 '{item}'，已跳过。", file=sys.stderr)
                  source_section = "[project.dependencies]"
             elif isinstance(dep_list, dict): # Also check if it's already a dict (less common for PEP621)
                  dependencies = dep_list
                  source_section = "[project.dependencies]"

        if not dependencies:
            print(f"警告: 在 '{os.path.basename(pyproject_path)}' 中未找到 [tool.poetry.dependencies] 或 [project.dependencies] 部分。", file=sys.stderr)
            return

        print(f"从 {source_section} 读取依赖项...")
        req_lines = []
        for name, version_spec in dependencies.items():
            if name.lower() == 'python': continue # Skip python constraint

            if isinstance(version_spec, str):
                if version_spec == "*": req_lines.append(name)
                else:
                    # Attempt to map simple specifiers - THIS IS HIGHLY SIMPLISTIC
                    # For robust conversion, external tools are better.
                    spec = str(version_spec).replace('^', '>=').replace('~', '~=')
                    # Crude check for common poetry/pep508 extras format
                    if '[' in name and ']' in name: # e.g., requests[security]
                         req_lines.append(f"{name}{spec}") # Pip understands this
                    else:
                         req_lines.append(f"{name}{spec}") # Simple name+spec

            elif isinstance(version_spec, dict):
                 # Handle complex cases like { version = "^1.0", optional = true } or git/path deps
                 print(f"警告: 依赖项 '{name}' 具有复杂定义，无法自动转换为 requirements.txt: {version_spec}", file=sys.stderr)
                 print("建议使用 'poetry export > requirements.txt' (如果使用Poetry) 或手动检查。")

        # Ask to overwrite
        if os.path.exists(req_path):
            overwrite = utils.get_user_choice(f"'{os.path.basename(req_path)}' 已存在。是否覆盖?", ["否", "是"], default_index=0)
            if overwrite == "否" or overwrite is None:
                print("操作取消。")
                return

        with open(req_path, 'w', encoding='utf-8') as f:
            f.write("# Generated by environment auxiliary tool\n")
            f.write(f"# Source: {os.path.basename(pyproject_path)} ({source_section})\n")
            f.write("# WARNING: Automatic conversion might be incomplete for complex dependencies.\n\n")
            f.write("\n".join(req_lines))
            f.write("\n") # Add trailing newline
        print(f"'{os.path.basename(req_path)}' 已生成/更新。请检查内容是否准确。")

    except FileNotFoundError: print(f"错误: 文件 '{os.path.basename(pyproject_path)}' 未找到。", file=sys.stderr)
    except toml.TomlDecodeError: print(f"错误: 解析 '{os.path.basename(pyproject_path)}' 文件失败。请检查 TOML 格式。", file=sys.stderr)
    except Exception as e: print(f"转换时发生错误: {e}", file=sys.stderr); traceback.print_exc()


def convert_req_to_pyproject(project_root):
    """Converts requirements.txt to a basic pyproject.toml (Poetry format)."""
    pyproject_path = os.path.join(project_root, 'pyproject.toml')
    req_path = os.path.join(project_root, 'requirements.txt')

    if not os.path.exists(req_path):
        print(f"错误: 未找到 '{os.path.basename(req_path)}' 文件。", file=sys.stderr)
        return

    print(f"正在尝试基于 '{os.path.basename(req_path)}' 生成/更新 '{os.path.basename(pyproject_path)}'...")

    try:
        with open(req_path, 'r', encoding='utf-8') as f:
            # Filter empty lines and comments, keep original line for better parsing
            lines = [line for line in f if line.strip() and not line.strip().startswith('#')]

        # --- Default pyproject structure (Poetry) ---
        # Use project dir name for package name suggestion
        project_name = utils.get_default_env_name(project_root) # Get sanitized name
        pyproject_data = {
            "tool": {
                "poetry": {
                    "name": project_name,
                    "version": "0.1.0",
                    "description": "",
                    "authors": ["Your Name <you@example.com>"], # Placeholder
                    "readme": "README.md", # Optional, common practice
                    "dependencies": {},
                    "group": { # Using groups for dev dependencies
                         "dev": {
                              "dependencies": {}
                         }
                    }
                }
            },
            "build-system": {
                "requires": ["poetry-core>=1.0.0"],
                "build-backend": "poetry.core.masonry.api"
            }
        }

        # --- Get Python version from config ---
        # Use the config module function correctly
        python_version = tool_config.get_default_python_version()
        # Format for pyproject.toml (e.g., "^3.10") - be careful with exact formatting
        # Using ~= might be safer if the default is like "3.10"
        if '.' in python_version:
            major_minor = '.'.join(python_version.split('.')[:2])
            python_specifier = f"^{major_minor}" # Common default: ^3.10
        else:
             python_specifier = python_version # Use as is if no dot found

        pyproject_data["tool"]["poetry"]["dependencies"]["python"] = python_specifier
        print(f"设置 Python 依赖为: {python_specifier}")

        # --- Parse requirements lines ---
        for line in lines:
            line = line.strip()
            # Basic parsing: Handles name, specifiers. Doesn't handle complex URLs, options like -e.
            # Regex tries to capture package name and the rest (version specifiers)
            match = re.match(r'^([a-zA-Z0-9._-]+)\s*([~<>=!]=?.*)?$', line)
            if match:
                name = match.group(1)
                version_spec = match.group(2).strip() if match.group(2) else "*" # Default to "*" if no specifier
                # Simple check: don't add python itself as a package dependency
                if name.lower() == 'python':
                     continue
                pyproject_data["tool"]["poetry"]["dependencies"][name] = version_spec
                # print(f"  添加依赖: {name} = \"{version_spec}\"") # Debug
            else:
                print(f"警告: 无法完全解析行 '{line}'。已跳过。", file=sys.stderr)
                print("  (可能包含编辑模式 '-e', URL, 或不支持的格式)")


        # Check if pyproject.toml already exists
        if os.path.exists(pyproject_path):
            # Add comparison logic here later if desired
            print(f"'{os.path.basename(pyproject_path)}' 已存在。")
            overwrite = utils.get_user_choice(f"是否覆盖?", ["否", "是"], default_index=0)
            if overwrite == "否" or overwrite is None:
                print("操作取消。")
                return
            else:
                print(f"正在覆盖 '{os.path.basename(pyproject_path)}'...")
        else:
             print(f"正在创建 '{os.path.basename(pyproject_path)}'...")


        with open(pyproject_path, 'w', encoding='utf-8') as f:
            toml.dump(pyproject_data, f)

        print(f"\n'{os.path.basename(pyproject_path)}' 已生成/更新。")
        print("请检查并完善内容 (如作者、描述、项目URL等)。")
        print("注意: 从 requirements.txt 转换可能不完美，特别是对于复杂的依赖项。")

    except FileNotFoundError: print(f"错误: 文件 '{os.path.basename(req_path)}' 未找到。", file=sys.stderr)
    except Exception as e: print(f"转换时发生错误: {e}", file=sys.stderr); import traceback; traceback.print_exc()


def generate_req_pipreqs(project_root, env_name):
    """Generates requirements.txt using pipreqs within the specified Conda environment."""
    req_path = os.path.join(project_root, 'requirements.txt')

    if not env_name:
        print("错误: 需要指定 Conda 环境名称才能运行 pipreqs。", file=sys.stderr)
        return

    print(f"\n将在环境 '{env_name}' 中使用 pipreqs 生成 '{os.path.basename(req_path)}'...")
    print(f"(确保 pipreqs 已安装在 '{env_name}' 环境中: conda run -n {env_name} pip install pipreqs)")

    # Check if requirements.txt exists and ask for confirmation to overwrite
    if os.path.exists(req_path):
        overwrite = utils.get_user_choice(f"'{os.path.basename(req_path)}' 已存在。是否覆盖?", ["否", "是"], default_index=0)
        if overwrite == "否" or overwrite is None:
            print("操作取消。")
            return

    # Command to run pipreqs inside the conda environment
    # Use '--force' to overwrite existing requirements.txt
    # Specify project root explicitly for pipreqs
    command = [
        'conda', 'run', '-n', env_name, '--no-capture-output', # Allow output to show
        'pipreqs', '.', '--encoding=utf-8', '--force'
        # Consider adding common ignores: e.g. '--ignore .venv,.env,tests,docs'
    ]

    try:
        # Run command in the project root directory, show output
        print(f"运行 pipreqs (这可能需要一些时间)...")
        result = utils.run_command(command, cwd=project_root, check=False, verbose=True) # verbose=True to see pipreqs output/errors

        if result.returncode == 0:
             print(f"\npipreqs 成功完成。'{os.path.basename(req_path)}' 已生成/更新。")
             print("注意：pipreqs 基于 import 语句生成，可能不包含所有依赖项（如插件或动态加载的库）。请务必检查文件内容。")
        else:
             print(f"\npipreqs 执行失败。返回码: {result.returncode}", file=sys.stderr)
             print("请检查：", file=sys.stderr)
             print(f"  1. Conda 环境 '{env_name}' 是否存在且包含项目运行所需的所有库?", file=sys.stderr)
             print(f"  2. pipreqs 是否已安装在 '{env_name}' 环境中?", file=sys.stderr)
             print(f"  3. 项目代码 ('{project_root}') 是否存在语法错误?", file=sys.stderr)
             # stderr from run_command should already be printed by utils.run_command if verbose=True

    except FileNotFoundError:
         # This usually means 'conda' command itself was not found
         print("错误: 'conda' 命令未找到。请确保 Conda 已正确安装并添加到系统 PATH。", file=sys.stderr)
    except Exception as e:
         print(f"运行 pipreqs 时发生异常: {e}", file=sys.stderr)
         import traceback; traceback.print_exc()

# global_tools/dependency_manager.py
import os
import time # Import time module
import sys
import toml
import re
import traceback # Import traceback
from . import utils
from . import config as tool_config

# ... (existing functions: convert_pyproject_to_req, convert_req_to_pyproject, generate_req_pipreqs) ...

# --- Add the new function here ---
def check_and_prompt_sync(project_root):
    """
    Checks for pyproject.toml and requirements.txt, compares modification times,
    and prompts the user to synchronize them if one is missing or significantly newer.
    """
    pyproject_path = os.path.join(project_root, 'pyproject.toml')
    req_path = os.path.join(project_root, 'requirements.txt')
    pyproj_base = os.path.basename(pyproject_path)
    req_base = os.path.basename(req_path)

    try:
        pyproj_exists = os.path.exists(pyproject_path)
        req_exists = os.path.exists(req_path)

        # Get modification times (0 if file doesn't exist)
        pyproj_mtime = os.path.getmtime(pyproject_path) if pyproj_exists else 0
        req_mtime = os.path.getmtime(req_path) if req_exists else 0

        # Time difference threshold in seconds (e.g., 5 seconds)
        # If mod times are within this threshold, consider them 'concurrent'
        time_threshold = 5

        action_taken = False # Flag to check if any sync action was performed

        print("\n--- 依赖文件同步检查 ---")

        if pyproj_exists and not req_exists:
            print(f"检测到 {pyproj_base} 但没有 {req_base}。")
            choice = utils.get_user_choice(
                f"是否尝试从 {pyproj_base} 生成 {req_base}? (警告: 可能不完整)",
                ["否", "是"], default_index=0
            )
            if choice == "是":
                print(f"\n正在执行: {pyproj_base} -> {req_base}")
                convert_pyproject_to_req(project_root)
                action_taken = True

        elif not pyproj_exists and req_exists:
            print(f"检测到 {req_base} 但没有 {pyproj_base}。")
            choice = utils.get_user_choice(
                f"是否根据 {req_base} 生成基础的 {pyproj_base}?",
                ["否", "是"], default_index=0
            )
            if choice == "是":
                print(f"\n正在执行: {req_base} -> {pyproj_base}")
                convert_req_to_pyproject(project_root)
                action_taken = True

        elif pyproj_exists and req_exists:
            time_diff = abs(pyproj_mtime - req_mtime)

            # Only prompt if one file is significantly newer than the other
            if time_diff > time_threshold:
                if pyproj_mtime > req_mtime:
                    newer_file, older_file = pyproj_base, req_base
                    action = f"从较新的 {newer_file} 更新 {older_file}?"
                    convert_func = convert_pyproject_to_req
                else:
                    newer_file, older_file = req_base, pyproj_base
                    action = f"从较新的 {newer_file} 更新 {older_file}?"
                    convert_func = convert_req_to_pyproject

                print(f"检测到 '{newer_file}' 比 '{older_file}' 更新。")
                choice = utils.get_user_choice(
                    f"{action} (警告: 可能覆盖 '{older_file}' 中的手动修改)",
                    ["否", "是"], default_index=0
                )
                if choice == "是":
                    print(f"\n正在执行更新: {newer_file} -> {older_file}")
                    convert_func(project_root)
                    action_taken = True
            else:
                # Files exist and modification times are close, do nothing automatically
                print(f"检测到 {pyproj_base} 和 {req_base}，修改时间接近，无需同步。")

        else: # Neither file exists
           print(f"未检测到依赖文件 ({req_base} / {pyproj_base})。")

        # print("--- 依赖文件检查完成 ---") # Footer might be too noisy

        # Pause only if an action was taken and user confirmed it
        if action_taken:
            input("同步操作完成，按回车键继续...")

    except Exception as e:
        print(f"依赖文件同步检查时发生错误: {e}", file=sys.stderr)
        # Optionally print traceback for debugging
        # import traceback
        # traceback.print_exc()